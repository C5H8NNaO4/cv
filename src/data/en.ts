const translation = {
  translation: {
    description: `
I'm a {{age}}-year-old software developer from Germany. 
My favorite language is without a doubt <del>JavaScript</del><mark>TypeScript</mark>. It's the language I grew up with, learning to code and still love to use on a daily basis {{consts.TRAINING_START}} years later. 
I'm really happy to see the language evolve, driven by the community, and see tools like Babel grow from an experiment to the leading standard for transpiling JavaScript. 
I have about <mark>{{experience.JavaScript}} years</mark> of in-depth knowledge in <mark>JavaScript</mark> and can handle complex tasks like writing a compiler.
I spent about {{experience.Node-js}} years on Node.js and have experience with a variety of frameworks like {{tags.frameworks}}, etc... 
React is definitely my favorite framework of the last years and has been what kept me fascinated over the past years. 
I have experience working with experienced remote teams of senior developers in an agile environment using Scrum. 
I value <mark>code quality</mark> over quantity and am experienced in working with and maintaining a high-quality codebase. 
As a team we leverage unit tests, end-to-end tests and visual regression tests to assure quality and reduce the workload of QA. As with most experienced scrum teams, staged environments, <mark>CI/CD</mark> pipelines, and thorough code review are a standar. 
I love to code, and I highly appreciate quality code. I prefer TypeScript over JS because type safety is a valuable tool to vastly reduce the chance of introducing bugs. 
I’m used to restrictive <mark>ESLint</mark> rulesets and formatters. I'm well familiar with Git and Docker and use both on a daily basis. I have been using Kubernetes a lot over the past two years. I have experience writing serverless applications on AWS (Lambda) and DynamoDB. I love writing bots, from code-golfing and king-of-the-hill battles, crypto trading bots driven by technical analysis to processing high-frequency real-time sensor data evaluating complex rulesets. I like to experiment a lot, so most of my projects don't make it past a proof of concept stage as the last 20% are usually the most time-consuming. My favorite project was a live preview feature for a code editor as seen in Apple's Swift Playground which shows the result of each line of code aside of it. The information is derived by static source code analysis - a concrete interpretation of an expression's value is computed by performing data flow analysis on the CFG which contains information about its lexical and variable environment and allows the program to resolve variables and function references. It’s amazing to see what level of information you can extract from statically analyzing source code. It’s based on my optimizing ES5 compiler, which is pretty much the same as Babel and has become obsolete once Babel was released. I spent the last two years working with analyzing and processing high quantities of real-time data (about 1.5M data points/day) and the problems that arise trying to analyze that amount of disjoint data. I’m currently developing a server-side framework that implements React on the server side and allows you to develop production-grade highly modular backend components with a 1-to-1 coupling to frontend components. Server-side components are written using JSX and support most of the coding pragmas that frontend React components allow. It’s fully decentralizable, runs vServerless out of the box, and supports atomic writes when used with compatible databases. Using this approach, you can develop an ecosystem of highly reusable components that include backend and frontend logic in a single maintainable component.
    `,
  },
};

export default translation;
